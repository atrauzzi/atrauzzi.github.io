"use strict";(self.webpackChunkpersonal_blog_of_alexander_trauzzi=self.webpackChunkpersonal_blog_of_alexander_trauzzi||[]).push([[29],{428:function(e,t,n){n.r(t),n.d(t,{default:function(){return h}});var a=n(8453),r=n(6540);function o(e){const t=Object.assign({p:"p",a:"a",em:"em",h3:"h3",pre:"pre",code:"code",strong:"strong",ol:"ol",li:"li",hr:"hr"},(0,a.R)(),e.components);return r.createElement(r.Fragment,null,r.createElement(t.p,null,"With .NET now competing on the cross platform, open source stage, something that often gets overlooked is the number of abstractions that come bundled with the core libraries.  One of which I recently started using being ",r.createElement(t.a,{href:"https://github.com/microsoft/FeatureManagement-Dotnet"},"Feature Management"),"."),"\n",r.createElement(t.p,null,"Feature management in .NET is interesting because like others abstractions in the framework, it merely defines the contract by which other code will consume the ",r.createElement(t.em,null,"concept of features"),". It leaves the implementations however, as something that can be plugged in from multiple sources.  I like to think of these designs as conversation starters for projects to rally around.  It's especially nice when they allow for multiple implementations to cooperate together!"),"\n",r.createElement(t.h3,null,"What You Gain"),"\n",r.createElement(t.p,null,"I think without taking too much away from the official documentation, feature management gives you one central place to see if a ",r.createElement(t.em,null,"feature")," is available. What those ",r.createElement(t.em,null,"features")," are and their significance is something that you're empowered to design based on whatever your application needs!"),"\n",r.createElement(t.pre,null,r.createElement(t.code,{className:"language-csharp"},'\npublic class MyService\n{\n    private readonly IFeatureManager featureManager;\n\n    public MyService(IFeatureManager featureManager)\n    {\n        this.featureManager = featureManager;\n    }\n\n    public async Task PerformSomeTask()\n    {\n        if (await featureManager.IsEnabledAsync("vnext-preview"))\n        {\n            // Do vnext preview things!\n        }\n    }\n}\n')),"\n",r.createElement(t.p,null,"It even ships with an ASP.NET filter:"),"\n",r.createElement(t.pre,null,r.createElement(t.code,{className:"language-csharp"},'\n[FeatureGate("vnext-preview")]\npublic class OrganizationController : Controller\n{\n    // note: You can also apply the annotation above to methods/actions!\n}\n')),"\n",r.createElement(t.h3,null,"Putting It To Use"),"\n",r.createElement(t.p,null,"By default, feature management ships with the ability to configure your features statically using the ",r.createElement(t.a,{href:"https://docs.microsoft.com/en-us/aspnet/core/fundamentals/configuration"},".NET configuration system"),". This also includes some neat utility filters that can help you do things like A/B testing as well as time based access."),"\n",r.createElement(t.p,null,"All of this is dependent on you having your features defined at run time, but what if you happen to have some additional feature information that isn't part of your deployments?  What if you want to flow-in feature state based on an entitlement or billing system where the data is stored somewhere outside of the application?"),"\n",r.createElement(t.p,null,"Enter ",r.createElement(t.em,null,"feature filters"),"!"),"\n",r.createElement(t.p,null,"I admit, the name still doesn't seem intuitive, even after getting things working. It took me a bit to wrap my head around the specific intent behind the word ",r.createElement(t.em,null,"filter"),".  A feature filter is a piece of code ",r.createElement(t.strong,null,"registered as a singleton")," that gets called numerous times to give a thumbs up or a thumbs down on whether features are enabled.\nUpon being asked, feature filters have to be able to source the information they need to return a ",r.createElement(t.code,null,"true")," or ",r.createElement(t.code,null,"false")," response back to the feature management system."),"\n",r.createElement(t.p,null,"Keep in mind that bit I mentioned about it being registered as a singleton though, we'll come back to that..."),"\n",r.createElement(t.h3,null,"Using Feature Filters During Requests"),"\n",r.createElement(t.p,null,"In my application, I load in data about the current tenant and user on every request and I pack it into a special context object. This data, despite being a complicated graph is easy to cache because it is very consistent between requests. The context object can be thought of something somewhere half way between ",r.createElement(t.code,null,"HttpContext")," and ",r.createElement(t.code,null,"DbContext")," and is a resource for anywhere in the application where infrastructure and domain must interact."),"\n",r.createElement(t.p,null,"In this next code sample, you'll see me using it when I use service location to look up a type called ",r.createElement(t.code,null,"AppContext"),". Let's get the code in front of us, and then after I'll explain what's going on and also more about the singleton gotcha:"),"\n",r.createElement(t.pre,null,r.createElement(t.code,{className:"language-csharp"},'\nnamespace App.Http\n{\n    public class AppFeatureFilter : IFeatureFilter\n    {\n        private readonly IHttpContextAccessor httpContextAccessor;\n\n        public AppFeatureFilter(\n            ILogger<AppFeatureFilter> logger, \n            IHttpContextAccessor httpContextAccessor\n        )\n        {\n            this.logger = logger;\n            this.httpContextAccessor = httpContextAccessor;\n        }\n\n        public async Task<bool> EvaluateAsync(FeatureFilterEvaluationContext context)\n        {\n            var httpContext = httpContextAccessor.HttpContext;\n\n            // 1.\n            if (httpContext == null)\n            {\n                logger.Log(LogLevel.Information, $"Feature {feature.Name} was checked outside of an http context.");\n\n                return false;\n            }\n\n            // 2.\n            var appContext = httpContext.RequestServices.GetRequiredService<AppContext>();\n\n            var currentUser = await appContext.User;\n\n            // 3.\n            return currentUser.Features.Contains(feature);\n        }\n    }\n}\n')),"\n",r.createElement(t.ol,null,"\n",r.createElement(t.li,null,"\n",r.createElement(t.p,null,"As a bit of due diligence, I like to ensure that if for any reason my filter is called outside of a web request, I don't accidentally crash the application, and I also log a bit of information out. This code is unlikely to be run, but I'll thank myself for logging this here if ever I'm tracing a particularly tricky bug."),"\n"),"\n",r.createElement(t.li,null,"\n",r.createElement(t.p,null,"This is the main reason why I made this blog post as this was by far the most challenging thing to learn about creating a feature filter that is to be used per-request.",r.createElement("br"),"\nYou're probably wondering why I couldn't just inject the ",r.createElement(t.code,null,"HttpContext")," and be done with things. But remember earlier I mentioned that the feature filter is registered as a ",r.createElement(t.strong,null,"singleton"),"?  That means that there's only one instance for the entire application and for every web request.  Each call made to it is technically done against the same instance. This makes it doubly important to ensure that each time the feature filter is called, it obtains the request for the current thread and answers based on the ",r.createElement(t.code,null,"AppContext")," registered in the same scope as that ",r.createElement(t.code,null,"HttpContext"),"."),"\n"),"\n",r.createElement(t.li,null,"\n",r.createElement(t.p,null,"It probably goes without saying, but in this case, my user object has a property called ",r.createElement(t.code,null,"Features")," which traverses the object graph to build the full list of features available to the user. If you are adapting this example for your own use, this line is where you can figure out what you want to return, a ",r.createElement(t.code,null,"true")," or a ",r.createElement(t.code,null,"false"),"!"),"\n"),"\n"),"\n",r.createElement(t.hr),"\n",r.createElement(t.p,null,"If you're looking into whether you can make use of the feature management system, or if you've been trying to make sense of it, I hope you've found this quick little summary useful.  I think overall, it covers the main details and gotchas that I was missing as I was getting started with .NET feature management."),"\n",r.createElement(t.p,null,"I think a good supplement to this post would be a quick explainer on the ASP.NET request lifecycle as well as scoped services during dependency injection.  There are many resources out there that cover these concepts, although maybe one day I'll put together my own."))}var l=function(e){void 0===e&&(e={});const{wrapper:t}=Object.assign({},(0,a.R)(),e.components);return t?r.createElement(t,e,r.createElement(o,e)):o(e)},i=n(9200),s=n(5093),c=n.n(s);const u=e=>{let{data:t,pageContext:n,children:a}=e;const o=t.site.siteMetadata.title,l=t.mdx.frontmatter.title,s=c()(t.mdx.frontmatter.posted).format("LLLL"),u=t.package.version;return r.createElement(i.O,{title:o,showTitle:!1,pageTitle:l,byline:s,version:u},r.createElement("article",null,a))};function h(e){return r.createElement(u,e,r.createElement(l,e))}},8453:function(e,t,n){n.d(t,{R:function(){return l}});var a=n(6540);const r={},o=a.createContext(r);function l(e){const t=a.useContext(o);return a.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}}}]);
//# sourceMappingURL=component---src-pages-mdx-frontmatter-slug-tsx-content-file-path-posts-2-md-710a21a479d940615b89.js.map