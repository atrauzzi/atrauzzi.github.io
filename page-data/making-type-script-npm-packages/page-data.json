{"componentChunkName":"component---src-templates-post-tsx","path":"/making-type-script-npm-packages","result":{"data":{"allPost":{"edges":[{"node":{"id":"blog-post-b131007c-845c-5324-a135-52bfae1c6585","parent":null,"internal":{"mediaType":"text/html","type":"post","owner":"default-site-plugin","ignoreType":null,"fieldOwners":null,"description":null,"contentDigest":"2016-12-18T16:39:04-08:00","content":"If you've landed here, I can only assume you're like me and see packages as the highest form of sophistication in software development. &nbsp;In that same vein, I bet at some point in the past you've wished you could start applying DRY principles to your client-side efforts. &nbsp;I know for myself, I don't enjoy writing the same application bootstrap code constantly and so recently, I was motivated to codify it.<br />\n<br />\nThis body of understanding has taken me quite some while to figure out, hopefully what I share here is helpful enough to get you up to speed. &nbsp;No post is complete without some kind of example, so throughout I'm going to reference a package I've just finished putting together called <a href=\"https://github.com/atrauzzi/protoculture\">protoculture</a>.<br />\n<br />\n<i><span style=\"font-size: x-small;\">Briefly described, protoculture encapsulates all the common bootstrap and conventions I've been using while developing TypeScript apps that use React and Redux. &nbsp;Honestly, I've already gotten a lot of benefit out of putting this package together, but nothing about this post will be coupled to its objective.</span></i><br />\n<h3>\nTypeScript</h3>\n<div>\nBased on the title, you shouldn't be surprised. &nbsp;The first thing I'm going to tell anyone looking to tame their front end code is to stop writing it in plain ES. &nbsp;Although with that said, much of this post focuses on the generic npm ecosystem, so if you are still committed to ES, I'm sure there are still plenty of useful tidbits here.</div>\n<div>\n<br /></div>\n<div>\nGetting into things, make sure you understand TypeScript itself and have an appreciation for authoring code in it. &nbsp;This should start with really getting a handle on tsconfig.json which even took me a bit to appreciate fully.</div>\n<div>\nOnce you're in the swing of things, try to look for opportunities to make use of things like enums and generics. Explore TypeScript and find ways make your code more expressive and easier to consume.</div>\n<div>\n<br /></div>\n<div>\n<i>With regards to IDE support, they're in a bit of a weird space currently and can sometimes get in the way. Especially Visual Studio which still trips on its own solution and project models.</i><br />\n<i>Before you go too far writing any TypeScript code, throw a tsconfig.json in your projects early and play by the rules.</i><br />\n<i>If you really need a suggestion for an editor, look at Atom, Visual Studio Code or WebStorm, they are all quite strong.</i></div>\n<h3>\nBuilding TypeScript</h3>\n<div>\nBuilding your final outputs in the JavaScript space has got to be one of the most challenging things to gain a good mental model for. &nbsp;It's going to have to happen if we want to produce a package, so you'll have to commit to at least appreciating all the objectives.<br />\n<br />\nThe community has produced great tools like JSPM and WebPack which take care of module loading and bundling. Briefly explained:</div>\n<div>\n<ul>\n<li>Module loading is the convention where anything processing your code will go through a series of steps and specific locations to resolve your imports to actual JS code.</li>\n<li>Bundling is the process you go through to produce your final output. This usually ends up being one or several .js files that you reference from script tags.</li>\n</ul>\nBelieve it or not, for the sake of this blog post, we won't have to think about bundling! &nbsp;It makes sense that this is not in the picture as when we're making a library, we're only going to put the code in a state where it can be consumed by other projects. Not deliver it to web browsers for execution.</div>\n<div>\n<br /></div>\n<div>\nTo accomplish this, what I've resorted to doing when producing packages backed by TypeScript code is I <a href=\"https://github.com/atrauzzi/protoculture/blob/master/tsconfig.json#L4\">get tsc to produce its output as UMD modules</a>. &nbsp;This ensures that anyone looking to use your package can do so, regardless of what module system they're using inside of <i>their</i> project.</div>\n<div>\n<br /></div>\n<div>\nIf someone using your package is authoring their code in plain JS, they'll be on their way. Indeed one of the nice things about this process is that while your code will be written in TypeScript, consumers of your package won't be obligated to do the same.</div>\n<div>\nIf anyone intends on consuming your package from another TypeScript project however, this is only going to be half the story. &nbsp;I'll address the other half once a few other things have been established.</div>\n<h3>\nDocker</h3>\n<div>\nThis won't come as a surprise to people who know me, but I will containerize <b>anything that can be</b>. The benefits I've observed in doing this cannot be understated and if for whatever reason you've missed it up until now, it has become eye-rollingly easy to get started using <a href=\"https://docs.docker.com/docker-for-windows/\">Docker for Windows</a> and/or <a href=\"https://docs.docker.com/docker-for-mac/\">Docker for Mac</a>.</div>\n<div>\n<br /></div>\n<div>\nMy usage of docker in this scenario is simple. &nbsp;If I can orchestrate my tooling and processes through a container, then anyone can run them. &nbsp;Not only will we all then be using the same tools and have the same experience, but the process will run anywhere. &nbsp;Including my build server!</div>\n<div>\n<br />\nIt might be piling on a bit too much too early if you're really starting from scratch learning all of this. But I do suggest circling back afterwards and containerizing as a stretch goal.</div>\n<h3>\nnpm</h3>\n<div>\nGoes without saying, you need to be authoring a package.json to contain all your dependencies and metadata.</div>\n<div>\n<br /></div>\n<div>\nThis one is straightforward and most of your existing understandings of this file as a consumer are going to carry you. The main things to shore up will be to do with making sure your package is ready for others:</div>\n<div>\n<ul>\n<li>The <a href=\"https://github.com/atrauzzi/protoculture/blob/master/package.json#L4\">version string</a> as it is committed in source control will never change and should stay permanently fixed at something like 0.0.0-development. <br />Bear in mind that publishing your package will require that this version number be different to any prior version of your package that has been published. But I'll explain how that process works shortly.</li>\n<li>Be a good FOSS citizen and take the time to <a href=\"https://github.com/atrauzzi/protoculture/blob/master/package.json#L5\">choose</a> and appreciate a proper <a href=\"https://spdx.org/licenses/\">SPDX license identifier</a> for your package. &nbsp;All the cool kids are doing Apache 2 lately.</li>\n<li><a href=\"https://github.com/atrauzzi/protoculture/blob/master/package.json#L28-L29\">Identify the entrypoints</a>&nbsp;of your package. &nbsp;There are two types of entrypoints to know about for our purposes, I'll go into detail about what I've chosen shortly.</li>\n<ul>\n<li><a href=\"https://docs.npmjs.com/files/package.json#main\">main</a> - is standard according to npm and describes the script that will be returned when your root package is imported.</li>\n<li><a href=\"https://www.typescriptlang.org/docs/handbook/declaration-files/publishing.html\">types</a> - is used by TypeScript as a convention to indicate typing information for the entrypoint script.</li>\n</ul>\n</ul>\n<div>\nAnother file you're going to want to know about is .npmignore which is used to <a href=\"https://github.com/atrauzzi/protoculture/blob/master/.npmignore\">mask off files from being included during packaging</a>. &nbsp;You'll want this so that you don't include more than what is necessary when pushing your package to npm.</div>\n<div>\n<h3>\nYarn</h3>\n</div>\n</div>\n<div>\n<a href=\"https://yarnpkg.com/\">Yarn</a> is a recently-released although long in development drop-in replacement for npm. If you use server-side tooling like NuGet, composer or bundler, then you can basically think of this as bringing the quality of dependency management up to community expectations in one strike.</div>\n<div>\n<br /></div>\n<div>\nIt's designed to be fully compatible with npm, all you need to do is start using it and remember to <a href=\"https://github.com/atrauzzi/protoculture/blob/master/yarn.lock\"><span id=\"goog_1335252879\"></span>commit your lockfile to source control<span id=\"goog_1335252880\"></span></a>.</div>\n<h3>\nTypeScript and npm Revisited</h3>\n<div>\nWhile going over npm, I mentioned two entrypoint properties in package.json. &nbsp;The files they point to are clear when you read them and the respective documentation for the properties does a good enough job explaining things.<br />\nWhat wasn't immediately apparent when I was putting all of this together was how to produce these two files and what exactly they would correspond to. &nbsp;Especially when producing a library.<br />\n<br />\nLibraries are usually just inert functionality, waiting to be integrated. &nbsp;There is no entrypoint and nothing to invoke at a top level.<br />\n<br />\nNevertheless, consumers of your package are going to want some notion of the touchpoints you are exposing. &nbsp;With that in mind, your index actually ends up <a href=\"https://github.com/atrauzzi/protoculture/blob/master/src/index.tsx\">looking kind of like a header file</a>! &nbsp;When typescript goes to build your UMD modules, index.js will just be the JS equivalent of those re-exports and index.d.ts will export the corresponding type information. &nbsp;Spend a good amount of time understanding this as I think once understood, the motivations behind everything else gets clearer.<br />\n<br />\nSomething else recently improved in this space is <a href=\"https://blogs.msdn.microsoft.com/typescript/2016/06/15/the-future-of-declaration-files/\">the introduction of @types packages</a> for TypeScript. &nbsp;These packages are produced either by package maintainers or the community to allow people authoring TypeScript to get <a href=\"https://github.com/atrauzzi/protoculture/blob/master/package.json#L31-L38\">type hinting for packages not authored in TypeScript</a>.<br />\n<br />\nBefore&nbsp;@types, there was an external tool called Typings that would install these dependencies, much like npm would install its own packages. I spent a bit of time using this prior and have to say&nbsp;@types is a massive improvement. Especially when introduced alongside Yarn. &nbsp;Everything blends in nicely with the node_modules directory and at long last the ecosystem seems to be stabilizing around some standard expectations.</div>\n<h3>\nSemantic Release</h3>\n<div>\nThere's a lot of cool going on here, but this is a really nice one and my hat goes off to the maintainers of this project.</div>\n<div>\n<br /></div>\n<div>\nI mentioned earlier that you shouldn't put any real version numbers inside of your package.json file. This is for good reason, as I'm sure it's obvious that managing that by hand would become a burden. It also makes continuous delivery quite difficult.</div>\n<div>\n<br /></div>\n<div>\n<a href=\"https://github.com/semantic-release/semantic-release\">Semantic release</a> is an npm-based dev-time tool that shoulders the burden of coming up with a proper version number and publishing npm packages with them. &nbsp;It's extremely easy to get started using it, especially if you're using any CI platforms that are popular with the community.</div>\n<h3>\nContinuous Integration and Delivery</h3>\n<div>\nOne skill that I think people don't always spend enough time advancing is build and deployment. There are a number of very valid reasons for this, ranging from comfort and confidence to not having the infrastructure available to tinker with.</div>\n<div>\n<br /></div>\n<div>\nIf you're looking for a quick way to upgrade your skills, I can think of no better a teacher than producing open source packages. &nbsp;The purpose of the package is immaterial, you can seriously take the most menial of things that you deal with and turn them into packages.</div>\n<div>\n<br /></div>\n<div>\nWhat I'd like to first say is that <a href=\"https://travis-ci.org/\">Travis CI</a> is free for open source projects. &nbsp;Just go make yourself an account there and poke around the interface. It integrates fully with github and they have done such a good job coming up with a simple and intuitive experience that it can guide you into learning exactly what kind of objectives to seek out when configuring build flows.</div>\n<div>\nSecond, based on the publicly visible build information for <a href=\"https://travis-ci.org/atrauzzi/protoculture\">protoculture</a>&nbsp;you can see what goes on just by examining the logs. Configuring builds in Travis CI is done using a <a href=\"https://github.com/atrauzzi/protoculture/blob/master/.travis.yml\">simple .yml file</a>. &nbsp;No surprises or undocumented gotchas.</div>\n<div>\n<br /></div>\n<div>\nIn fact, if this is something you are thinking about taking on, you're now probably itching to read more about <a href=\"https://github.com/atrauzzi/protoculture/blob/master/Dockerfile\">what I've done with Docker</a>!</div>\n<h3>\nSummary</h3>\n<div>\nI've talked about a lot of different moving parts in this post and I think that's really what motivated me to author it. Creating packages for npm is not trivial - and automating it can be daunting. &nbsp;Adding a transpiled language like TypeScript doesn't help matters as you are removing yourself by one degree from the flow in the hopes of obtaining other structural advantages.</div>\n<div>\n<br /></div>\n<div>\nUp until recently I only had a rough blueprint of what the best practices were in the JavaScript space. There is a lot of cynicism and humour out there targeting node, npm and browser development. Much of it is a caricature of legitimate gripes, but most of the time I see through it as a way to avoid some very rewarding effort.</div>\n<div>\nBeing able to reuse code on the client side has given me a level of confidence similar to what I enjoy during server side development. &nbsp;Going forward, I know my abstractions will be much better suited for deployment and reuse because of the great tools made by the community.</div>\n<div>\n<br /></div>\n<div>\nI hope this post has helped you and as always if I think of any improvements or if anyone has a correction for me, I'll be sure to make edits.</div>\n"},"slug":"making-type-script-npm-packages","title":"Making TypeScript npm Packages","created":"2016-12-19T00:21:00.000Z","updated":"2016-12-19T00:39:04.000Z"}}]}},"pageContext":{"slug":"making-type-script-npm-packages"}},"staticQueryHashes":["3220165301"]}