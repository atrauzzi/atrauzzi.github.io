{"componentChunkName":"component---src-templates-post-tsx","path":"/domain-layers-and-subclassing-an-api-in-php","result":{"data":{"allPost":{"edges":[{"node":{"id":"blog-post-08b0a494-51b3-505b-b626-1618024dc4fc","parent":null,"internal":{"mediaType":"text/html","type":"post","owner":"default-site-plugin","ignoreType":null,"fieldOwners":null,"description":null,"contentDigest":"2014-10-16T13:48:57-07:00","content":"A friend of mine who I occasionally help with development tasks came to me the other day asking about starting a project which would involve leveraging an API.<br />\n<br />\nGiven that I develop APIs and domain architecture, this seemed like a pretty good fit for my talents. &nbsp;I can produce the business logic and a simple chrome extension that talks to it and then we can explore further opportunities later, knowing that everything has been nicely abstracted.<br />\n<br />\nI've coded against a few public APIs in my time for various things ranging from social media to push messaging. &nbsp;Although each time, I'm always left feeling like what I did was never a first-class citizen in my project. &nbsp;In many cases with APIs, you're only leveraging the external model, but in the case of my new project, I actually plan on \"extending\" it...<br />\n<br />\nRead on if you're interested in any of the techniques involved, including repositories and project structure.<br />\n<h2>\nExtension Defined</h2>\n<div>\nWhen working with an external set of data, you have at least two choices. &nbsp;You can either harvest data from it and blend it into your own schema, or you can decide that the external representation of data is in fact part of your internal domain.</div>\n<div>\nBecause my entire solution targets the external platform, it made more sense to me to codify that in my abstraction. &nbsp;This is so that I always remain compatible and more aware of changes on their end &nbsp;-&nbsp;<span style=\"font-size: x-small;\">which I <i><b>am</b></i>&nbsp;in fact responsible for adapting to!.</span></div>\n<div>\n<br /></div>\n<div>\nThis is also good when you don't necessarily want or need to take a local copy of the external data, but only maintain what you're adding to the schema. &nbsp;Keep in mind, there is a sliding scale here which my design can address. &nbsp;You don't want to be performing API requests for every small anonymous operation if that's your use case, consider caching in those scenarios.</div>\n<div>\n<br /></div>\n<div>\nIf however, your project is mostly background work, there might be a justification for not storing the data, let alone letting it get stale. &nbsp;Again, it's a sliding scale which is an exercize left to the reader <span style=\"font-size: x-small;\">(for now)</span>.</div>\n<h2>\nFamiliar Constructs</h2>\nAs I've been exploring non-<a href=\"http://goo.gl/wqrQsH\" target=\"_blank\">leaky</a> project architectures, a natural solution <span style=\"font-size: x-small;\"><i>(that I don't take full credit for)</i></span>&nbsp;that occured to me is to wrap the external API in a domain layer. &nbsp;Very similar to what you might make as a package to then depend on in your framework project, this is a repository layer that that instead of talking to MySQL, Postgres or MongoDB, talks to HTTP!<br />\n<br />\nThis package consists of models, repositories and if necessitated in any way, could probably even contain domain services. &nbsp;Although I'd say 99% of the time, most API access is so simple, a domain service would not be necessary. &nbsp;Agian though, it's not completely ruled out, so if there's additional behaviour involved with accessing your remote API, the option is there.<br />\n<br />\n<br />\n<div style=\"text-align: center;\">\n<table align=\"center\" cellpadding=\"0\" cellspacing=\"0\" class=\"tr-caption-container\" style=\"margin-left: auto; margin-right: auto; text-align: center;\"><tbody>\n<tr><td style=\"text-align: center;\"><a href=\"http://goo.gl/0uJLbT\" style=\"margin-left: auto; margin-right: auto;\" target=\"_blank\"><img border=\"0\" src=\"http://1.bp.blogspot.com/-uOdhJqegzpc/VEAA9_u2OeI/AAAAAAAAVKw/w-IU9f5SIX4/s1600/Domain%2BLibrary%2BStructure.png\" height=\"480\" width=\"640\" /></a></td></tr>\n<tr><td class=\"tr-caption\" style=\"text-align: center;\"><span style=\"font-size: small; text-align: start;\">Here's how things might break down in your project and libraries' structures.</span></td></tr>\n</tbody></table>\n<span id=\"goog_740734792\"></span></div>\n<h3>\n<ul>\n<li>Project</li>\n</ul>\n</h3>\n<ul><ul>\n<li>Uses services found in your <b style=\"text-decoration: underline;\">domain library</b>&nbsp;in controllers, filters, middleware, commands, etc...</li>\n<li>Depends on specific storage like MySQL, Postgres or MongoDB as a package</li>\n<li>Depends on your domain library as a package</li>\n<li>Contains repositories that interact with your storage and the api</li>\n<ul>\n<li>Implements domain library repository interfaces</li>\n<li>Composes the repository layer from your <u><b>api/external domain library</b></u></li>\n</ul>\n</ul>\n</ul>\n<h3>\n<ul>\n<li>Domain Library</li>\n</ul>\n</h3>\n<ul><ul>\n<li>Depends on your <u><b>api/external domain library</b></u> as a package</li>\n<li>Defines repository interfaces that extend api domain library interfaces</li>\n<ul>\n<li>Does not implement them!</li>\n</ul>\n<li>Provides domain services that perform business logic using <u>domain library</u> interfaces</li>\n<ul>\n<li>Instances of classes implementing domain library interfaces typically originate from the project <span style=\"font-size: x-small;\"><i>(and usually with the help of a DI setup)</i></span></li>\n</ul>\n<li>Defines models that extend api/external domain library models</li>\n</ul>\n</ul>\n<h3>\n<ul>\n<li>API/External Library</li>\n</ul>\n</h3>\n<ul><ul>\n<li>Defines a repository interface</li>\n<li>Implements the repository interface</li>\n<li>Defines models</li>\n</ul>\n</ul>\nAs you can see, this is just the repository pattern, with some advice on how to structure your subclassing and composition to preserve functionality!<br />\n<ul>\n</ul>\n<h2>\nThinking it Through</h2>\n<div>\nIn my situation, what I ended up doing was creating a <a href=\"https://github.com/atrauzzi/toggl-sdk/blob/master/src/Repository/Api/Base.php\" target=\"_blank\">base repository class</a>&nbsp;in my api/external library that abstracts away the minutae of calling the API I'm wrapping. &nbsp;I made it able to return raw, array or domain objects from the API, in effect making it behave like a very primitive object-api-manager.</div>\n<div>\n<br /></div>\n<div>\nThere will usually be specifics when it comes to implementing these kinds of things that will depend on what you're accessing. &nbsp;But the nice part is that there is now somewhere to hide these abstractions from the layers that only wish to consume business objects. &nbsp;In my case, when it's time to update how the API is accessed, or add support for a new endpoint or feature, anyone reading my code knows exactly where to go!</div>\n<div>\n<br /></div>\n<div>\nSome advice I like to offer when people are serious about their domain design:</div>\n<div>\n<ul>\n<li>Don't use ORMs or libraries that require you to subclass a base model type</li>\n<li>Stay away from active-record-like systems which conflate repository and model</li>\n<li>Refrain from putting methods in your models that require access to global or injected infrastructure - those methods belong in a service</li>\n<li>Store data as attributes/properties on your model so that tools can reflect on them</li>\n</ul>\n<div>\nMoving outwards from the external/api repositories, you reach actual project domain. &nbsp;This layer extends the external/api repositories and models to remain signature compatible while also adding it's own specifics. &nbsp;</div>\n<div>\nThe new interfaces will later be implemented from within the more concrete project where persistance and other niceties are established. &nbsp;That means there are no interface implementations in the domain library, but instead domain service implementations. &nbsp;This is another composable layer where you work with your models and is where you really see things pay off. &nbsp;It can seem a little tricky here, but if you refer to the diagram above, it's simply that your project is going to implement what your domain services depend on, that's all.</div>\n<div>\n<br /></div>\n<div>\nFinally, you have your project. &nbsp;Which after all these efforts should be implementing your final repository interfaces as mentioned above and making use of the models and services they facilitate. &nbsp;Which, if that's the case, congratulations! &nbsp;Ideally you'll also have a dependency injection container to weave it all together. &nbsp;Depending on what tools you're using that may require some configuration.</div>\n<div>\n<br /></div>\n<div>\nDon't worry, it's still possible to maintain idiomatic syntax while following these guidelines. &nbsp;Especially if you use an ORM like doctrine which is able to hydrate relations transparently, just pick best-of-breed tools that keep your concerns in mind.</div>\n</div>\n<h2>\nWhy?</h2>\n<div>\nI probably use this heading a little too often, but it's a good question to be continuously asking.</div>\n<div>\n<br /></div>\n<div>\nAfter all the toil of extracting this separation, you might be curious as to what it nets you. &nbsp;Well, if you review my examples thus far, you might have noticed that I use the word \"package\" a fair bit. &nbsp;For every level of separation here (3 in total), you actually have a clean break between layers of code. &nbsp;<span style=\"font-size: x-small;\"><i>(In my situation, they are self-contained composer packages that can neatly track issues and changes without getting confused with irrelevant details.)</i></span></div>\n<div>\n<br /></div>\n<div>\nIn the first package, you have your base project which will be where the rubber meets the road. &nbsp;Once you decide upon a framework, you should also have an idea of how you will be persisting your data and what the entry points for your functionality are. &nbsp;All those dependencies are maintained at the project level.</div>\n<div>\n<br /></div>\n<div>\nIn the second and third packages, you have what defines your domain <u>as it is known without the framework</u>.</div>\n<div>\nThat's an uncommon consideration these days, as people are encouraged to put this code in their base projects in the name of rapid development. &nbsp;And it isn't necessarily wrong from that point of view. &nbsp;But the tendency has been that it ends up introducing unnecssary coupling to things like requests, sessions and error feedback. &nbsp;Over time, maintainability will suffer and you'll end up with the usual big ugly codebase nobody likes to work on or make sense of.</div>\n<div>\n<br /></div>\n<div>\nBy maintaining separate domain packages, you guarantee yourself the ability to transition to new frameworks as they come along (<a href=\"http://en.wikipedia.org/wiki/You_aren't_gonna_need_it\" target=\"_blank\">YAGNI</a> alert!) and more importantly - a clean separation between business logic and request handling. &nbsp;If you enjoy any modest level of success, you will also observe some benefits when it comes to managing scope and how hard your code is on your databases (scalability!).</div>\n<div>\n<br /></div>\n<div>\nAs always, it's your responsibility as the project architect to look into your crystal ball and know what the future might be like. &nbsp;If your project is going to be more than a prototype, it's in your best interest to consider these changes early as you get started or transition from a proof of concept.</div>\n<h2>\nConclusion</h2>\n<div>\nSo, I hope you've enjoyed this quick little tour of how you can produce a domain layer that accesses an API. &nbsp;I encourage you to look at my new <a href=\"https://github.com/atrauzzi/toggl-sdk\" target=\"_blank\">toggl sdk</a> which employs the first part of these designs. &nbsp;Everything I've written here and the diagram above is more than enough to infer how to complete the rest if you're interested in trying it out.</div>\n<div>\n<br /></div>\n<div>\nWhat I've written here is not exclusive to PHP. &nbsp;I think after adapting to whatever constructs are available in each environment, these guidelines can be applied to many different languages.</div>\n<div>\n<br /></div>\n<div>\nIf you're interested in knowing my specific stack, right now I'm keeping up with Laravel 5 <span style=\"font-size: x-small;\"><i>(which is super alpha at the moment)</i></span>, and using my <a href=\"https://github.com/atrauzzi/laravel-mongodb\" target=\"_blank\">laravel-mongodb package</a> for persistence. &nbsp;The rest of my project is private code, but I've shared as much as I can here with you and on github! :)</div>\n"},"slug":"domain-layers-and-subclassing-an-api-in-php","title":"Domain Layers and Subclassing an API in PHP","created":"2014-10-16T20:32:00.000Z","updated":"2014-10-16T20:48:57.000Z"}}]}},"pageContext":{"slug":"domain-layers-and-subclassing-an-api-in-php"}},"staticQueryHashes":["3220165301"]}