{"componentChunkName":"component---src-templates-post-tsx","path":"/my-new-way-of-using-php-traits-interfaces","result":{"data":{"allPost":{"edges":[{"node":{"id":"blog-post-ed118980-e50a-5175-998e-f4e5a7725ab6","parent":null,"internal":{"mediaType":"text/html","type":"post","owner":"default-site-plugin","ignoreType":null,"fieldOwners":null,"description":null,"contentDigest":"2013-11-30T21:30:35-08:00","content":"A popular feature in Rails called \"mixins\" came to PHP a while back under the name \"traits\". &nbsp;Traits let library developers give you a lot of functionality with little to no effort by injecting code into your classes that runs as if originally authored in them.<br />\nJust toss a line of code into the class you want to augment and you're off to the races.<br />\n<br />\nThe one snag I found when using traits however is that they don't participate in any kind of type system. &nbsp;If desperate enough, you can use reflection to pull out whether a class has one applied or not, but that's only half the battle and a lot of work each time.<br />\n<br />\nThis puts me in a slight bind when I'm interacting with classes using a trait I've made as I have no way to type check or hint them in.<br />\n<h3>\nBut then it dawned on me...</h3>\n<pre>interface MyInterface {\n     public function thisMethodIsImportant();\n}\n\ntrait MyInterfaceImpl {\n     public function thisMethodIsImportant() {\n          return \"Thanks for not forgetting about me!\";\n     }\n}\n</pre>\n<br />\nIt's pretty obvious what I'm doing here. &nbsp;I'm basically writing an interface to add to a class and then creating a trait that fulfils that interface.<br />\n<h3>\nThis leaves us with \"why?\"</h3>\nI think most of the time when someone is going to use your interface, they're going to wish that they didn't have to actually implement the methods it sets out. &nbsp;Which teaches us a little about how traits came to be: they're purely convenience.<br />\nInterfaces are a <b>good idea</b>, no question about it. &nbsp;It makes code easier to read and follow when you see classes that use them. &nbsp;Burdening consumers of your library with writing menial code however is not as useful and to a lesser extent so is forcing an implementation with traits.<br />\n<br />\nUsing this approach lets someone interested in your library take exactly as much as they need and leave the rest behind. &nbsp;If all they want is to stay in sync with my library and use the defaults, my trait and implementation will always be in sync, they don't have to worry. &nbsp;If however for some reason they need to abide by my library's contract but swap out how it's done? &nbsp;They're fully empowered to do so!<br />\n<br />\nI don't suspect I'm the first person to think of this, however I did come up with it on my own and it seems like a very considerate way to get the best of both worlds. &nbsp;Enjoy!"},"slug":"my-new-way-of-using-php-traits-interfaces","title":"My new way of using PHP Traits & Interfaces","created":"2013-12-01T05:30:00.000Z","updated":"2013-12-01T05:30:35.000Z"}}]}},"pageContext":{"slug":"my-new-way-of-using-php-traits-interfaces"}},"staticQueryHashes":["3220165301"]}