{"componentChunkName":"component---src-templates-post-tsx","path":"/laravel-project-architecture-the-missing-guide","result":{"data":{"allPost":{"edges":[{"node":{"id":"blog-post-6faabb75-7a1a-54d0-9063-04c44b12c8cc","parent":null,"internal":{"mediaType":"text/html","type":"post","owner":"default-site-plugin","ignoreType":null,"fieldOwners":null,"description":null,"contentDigest":"2013-08-09T16:34:35-07:00","content":"At my job, we've been doing a lot of learning and development using <a href=\"http://taylorotwell.com/\" target=\"_blank\">Taylor Otwell</a>'s <a href=\"http://laravel.com/\" target=\"_blank\">Laravel 4</a> PHP framework. &nbsp;As we've become more familiar with it, we've had to come up with better ways to structure our projects outside of what the documentation indicates and the default distribution that is provided.<br />\n<br />\nIf you've been working with Laravel 4 for any amount of time or come with experience from another framework and are just getting started, you've probably noticed that there are a lot of different ways to cut up your projects.<br />\n<br />\n<div class=\"separator\" style=\"clear: both; text-align: center;\">\n<a href=\"http://4.bp.blogspot.com/-KoI-poWQCGU/UgT0GsRdScI/AAAAAAAALBM/sRG1byo9UxI/s1600/genie-arms.jpg\" imageanchor=\"1\" style=\"margin-left: 1em; margin-right: 1em;\"><img border=\"0\" height=\"240\" src=\"http://4.bp.blogspot.com/-KoI-poWQCGU/UgT0GsRdScI/AAAAAAAALBM/sRG1byo9UxI/s320/genie-arms.jpg\" width=\"320\" /></a></div>\n<br />\n<div style=\"text-align: center;\">\nChoice is nice, but sometimes it can be paralysing or misleading.</div>\n<h2>\nConcrete Advice</h2>\nThis post is done in such a way that you can just skim the headings, but if you want a detailed explanation in each section, feel free to read in where necessary.<br />\n<br />\nWhile I can't say the entirety of my advice is in practice throughout the community, I can say that we are starting to use it, and to very good effect at my job. &nbsp;Especially considering that our apps tend to need both web and API front ends, good architecture is a very high priority.<br />\n<h3>\nUse Namespaces</h3>\n...properly! &nbsp;I've seen a lot of packages out there that classmap a file with a namespace declaration in it and yes while that's technically viable and nothing will blow up, it's cluttered. &nbsp;The whole idea behind <a href=\"https://github.com/php-fig/fig-standards/blob/master/accepted/PSR-0.md\" target=\"_blank\">PSR namespace</a> loading is that the files are easy to find and <a href=\"http://en.wikipedia.org/wiki/Cohesion_(computer_science)\" target=\"_blank\">cohesive</a>. &nbsp;Resorting to a \"<i>just find it all here under this esoteric name I've given it</i>\" approach makes your project more difficult for others to get up to speed with.<br />\n<br />\nHow do you namespace properly? &nbsp;At the root of your project (as in: adjacent to your <i>.git</i> directory), have a directory called \"<i>src</i>\". &nbsp;Inside of there you might have: \"<i>YourOrganization/YourProject</i>\", followed by all the necessary namespaces for the guts of your application. &nbsp;Some of which I will be clearly mentioning later in this post.<br />\n<br />\nThis is merely laying the groundwork for what's to come, but before we move on, there are two more suggestions I have which some people may disagree with:<br />\n<ul>\n<li>Never repeat namespace names in classes. &nbsp;So nothing like \"<i>YourOrganization\\YourProject\\Controller\\PostController\"</i>. &nbsp;If you need a different name for the class, alias it in the file where you're using it, where the meaning is <i><b>really</b></i> implied.</li>\n<li>Never pluralize your namespaces. &nbsp;It's not necessary and will make sense once you see a complete class name.</li>\n</ul>\n<h3>\nDon't use Facades in Namespaced Code</h3>\n<div>\nIt may seem tempting, but every time you do it, you're turning down an opportunity to make use of the IoC and reap the benefits of a clearer architecture. &nbsp;Instead, define a constructor on your class and list the dependencies there.</div>\n<h3>\nNamespace Your Models</h3>\n<div>\nIt's just going to be more organized that way and you'll be less inclined to abuse them.<br />\n<h3>\nOnly Extend Model</h3>\nI mean this in two ways:<br />\n<br />\nFirst, don't extend \"Eloquent\", extend the fully namespaced eloquent class \"Model\" itself.<br />\n<br />\nSecond, if you see a package claim along the lines of \"<i>oh yes, we will give you slugs, just extend our sluggable base class and away you go!</i>\", immediately put on the brakes. &nbsp;Go to that project's github page and open an issue titled: \"Use Traits Instead\" with the body text \"Please see title.\", click submit. &nbsp;The response will usually be \"<i>oh most people don't have PHP 5.4</i>\", at which point you can remind them what year it is and that PHP 5.3 is EoL.</div>\n<div>\n<h3>\nWrite Thin Models</h3>\n<div>\n...with no external dependencies. &nbsp;That means nothing like:</div>\n<div>\n<br /></div>\n<pre>    public function getUrlAttribute() {\n        return $this-&gt;urlGeneratorService-&gt;generateUrl($this-&gt;attributes['name']);\n    }\n</pre>\n<div>\n<br /></div>\n<div>\nIf you've been paying attention, you'll realize doing this in your model would force it to depend on an external service - and that implies a context, which is undesirable. &nbsp;If you write methods like this in your models, you will have architecture problems down the line.</div>\n<div>\n<br /></div>\n<div>\nIf there's some kind of transformation you need to perform on model data, it's entirely likely that it is specific to a certain circumstance that model may not always be finding itself in. &nbsp;That circumstance should never be coupled to the model itself, ever.<br />\n<br />\nWhat&nbsp;<b>can</b>&nbsp;you write in your models? &nbsp;Basically anything that leverages the model itself, its relations, internal PHP methods, scopes or something from the \"<i>Illuminate/Database/Eloquent\"</i>&nbsp;namespace.<br />\n<h3>\nCreate Repositories</h3>\nRepository classes represent the different graphs you'll be requesting from the database. &nbsp;A repository might look as simple as an Eloquent model getter (and seem redundant), but creating this layer will allow you to keep your classes from becoming a dizzy mess of queries.<br />\n<h3>\nEverything else is a Service</h3>\n<div>\nWhere something isn't a repository to fetch models from the database, you can create a service. &nbsp;Whether it's a utility to build static CDN URLs, or a social library that you've created. &nbsp;Most everything else in Laravel can be defined and injected as a service to be called. &nbsp;These can either call each other or be mixed and matched at the right level as needed.</div>\n<h3>\nNamespace your Controllers</h3>\nControllers will depend on services and/or repositories, and services are injected. Best to get them in the structure. &nbsp;Here's where I'd hope to find a controller in your project:<br />\n<br />\n<ul>\n<li>your-project/</li>\n<ul>\n<li>app/</li>\n<li>src/</li>\n<ul>\n<li>YourOrganization</li>\n<ul>\n<li>YourProjectName</li>\n<ul>\n<li>Controller</li>\n<ul>\n<li>Api</li>\n<ul>\n<li>User</li>\n<li>Post</li>\n<li>Social</li>\n</ul>\n<li>Web</li>\n<ul>\n<li>User</li>\n<li>Post</li>\n<li>Admin</li>\n</ul>\n</ul>\n<li>Model</li>\n<li>Repository</li>\n<li>Service</li>\n</ul>\n</ul>\n</ul>\n<li>public/</li>\n<li>vendor/</li>\n</ul>\n</ul>\n<div>\nNotice that I don't repeat names anywhere and everything is split up nicely based on roles. &nbsp;I have clean names to use in my routes and nobody has to go digging to find specific functionality. &nbsp;The separation of concerns in my project is clear based on this namespace structure alone.</div>\n<br />\n<h3>\nNon-Namespaced Files</h3>\nMigrations, views, routes, and configs are all the kinds of configuration-like framework files that don't need to be namespaced. &nbsp;This is where the facades really come in handy to grant your static code access to the dependency injection container.<br />\n<h3>\nOn Migrations</h3>\n<div>\nDon't use the enum type in Laravel 4 migrations currently as you'll lose the ability to alter the table later on down the line. &nbsp;Also, when authoring migrations for a package, write them to exist in the package and not to be copied into the main project by a command. &nbsp;This was something I got tricked into doing and it ended up being unoptimal when the time came for updates.</div>\n<h2>\nThe More Theoretical</h2>\n<div>\nThese next few are more to do with how your efforts on a general whole can be improved when working with Laravel 4. &nbsp;I just think they're a little more abstract than \"<i>do this with this here and not there</i>\".</div>\n<h3>\nDon't Subclass Packages</h3>\nIf you see a particular package in the wild and think to yourself \"hm, I just need to change this one method on this class...\", I urge you to reconsider. &nbsp;Either think about it from the angle of wrapping it with a service, or fork the project and turn the original package into an upstream source. &nbsp;The amount of confusion that can arise just from having multiple service providers attaching to the same realm of functionality as well as any potential model issues will mire you.<br />\n<h3>\nWrite Packages!</h3>\n...and then open source them! &nbsp;Release them to the community and help the community grow. &nbsp;I have a co-worker who firmly believes that nothing is too small to be a package. &nbsp;With the right designs in mind, I'd say he's right!<br />\n<br />\nHere's how I like my packages to look:<br />\n<br />\n<ul>\n<li>your-package/</li>\n<ul>\n<li>config/</li>\n<li>migrations/</li>\n<li>src/</li>\n<ul>\n<li>YourOrganization/</li>\n<ul>\n<li>YourPackageName/</li>\n<ul>\n<li>{any namespaces needed}/</li>\n<li><i>ServiceProvider.php</i></li>\n</ul>\n</ul>\n</ul>\n<li>composer.json</li>\n<li>readme.md</li>\n</ul>\n</ul>\n<div>\nI'm a bit on the fence about putting migrations and config in \"<i>src</i>\" as I think it should always be the root of a namespaced loader. &nbsp;If you have any thoughts on that, feel free to send me a comment!</div>\n<br />\n<h3>\nDon't Fight It!</h3>\n<div>\nI was given some good advice very early on when I started working with Symfony 1.4 which was to never try and fight the framework. &nbsp;Always work with the grain, go with the flow. &nbsp;Given the title of my blog, you can correctly conclude that I tend to challenge convention wherever possible. &nbsp;But that doesn't mean I'm immune to well thought explanations. &nbsp;In this, frameworks shine.</div>\n<div>\n<br /></div>\n<div>\nGenerally speaking, if a framework is popular and has a strong community, it stands to reason that many eyes have gone over the tools and given them a general \"<i>ok</i>\" in a broader scale design analysis. &nbsp;I think the <a href=\"http://en.wikipedia.org/wiki/Irresistible_force_paradox\" target=\"_blank\">irresistable force paradox</a> merits mention here.</div>\n<h3>\nUse the Local Development Server</h3>\n\n<div>\nDon't let the vagaries of any environment make you think that Laravel should be expected to behave differently in production. &nbsp;See my previous point. &nbsp;I think you'll find some parallels between this practice and writing tests for your code as well. &nbsp;If you can't download your project, install dependencies and then run <i>artisan</i>, you have a problem.</div>\n\n<h3>\nBe Pragmatic</h3>\nIf you haven't read the Pragmatic Programmer and are not familiar with one of Symfony (1.x or 2.x) or Ruby on Rails, do yourself a favour and read the book. &nbsp;I think a lot of the advice in that book urges us to think more about our work with a longer term focus than is normally seen. &nbsp;What's important is not making decisions out of convenience and being aware of impatient duplication, orthogonality and the broken windows theory. &nbsp;All of these topics are explored to good effect in the book and help us learn a lot about ourselves as developers.<br />\n<h3>\nBe Still</h3>\nI have one of my own to add which is to always try and write as little code as possible. &nbsp;Code that conducts excessive checks or produces more data structures than is necessary always has to be balanced somewhere else down the line. &nbsp;All of my advice here in a lot of ways is based on the desire to keep things DRY and simple.<br />\n<br />\n<br />\nAlright, that's it for now! &nbsp;New guidelines can come along in another post if I come up with a decent enough list.<br />\nI've been tinkering away at this post for a bit and I think what's in here is good enough to share. &nbsp;It's definitely the kind of resource I had hoped for when getting started with Laravel. &nbsp;Please feel free to post a comment with your thoughts or improvements.<br />\n<br />\nKeep in mind that what I've listed here is actually a combination of things I've discovered both on my own as well as through the community.</div>\n</div>\n"},"slug":"laravel-project-architecture-the-missing-guide","title":"Laravel Project Architecture: The Missing Guide","created":"2013-08-09T23:20:00.000Z","updated":"2013-08-09T23:34:35.000Z"}}]}},"pageContext":{"slug":"laravel-project-architecture-the-missing-guide"}},"staticQueryHashes":["3220165301"]}